<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>

	元素的js (五个部分)

	一, js基础

	编程的三要素
	1.数据 变量 常量

	数据类型: 基本数据类型(值类型)  引用数据类型

	基本数据类型: number string boolean undefined null
	引用数据类型: object(array Date Math regExp)  function 

	运算符: 
	类型的转换:

	2. 流程控制 (顺序 分支 循环)
	分支: if()  if(){}else()   if(){}else if(){}  switch case
	循环: for    while  do()while   for in    forEach
		break 跳出循环  continue  结束当前循环 开始下一次循环

	3. 函数  
		函数的声明与函数的调用
		函数的四种调用模式:
		Foo() 函数模式
		o.foo() 方法模式
		New foo() 构造器模式
		Foo.apply()/Foo.call()  上下文调用模式

	二.BOM 与 DOM
	
	1. BOM window对象
		属性: name innerHeight ...
		方法: alert()  confirm() prompt() setTimeout() setInterval()

		window对象的子对象:
			document:

			Screen:

			Location: href

			Navigator:

			History: go()  back()  forward();

	2. DOM
		
	三. 事件与时间对象
		onclick()  event

	四. 面向对象与高级
		1.预解析
		
		2.闭包: 函数外部访问函数内部的变量

		3.正则 
			1.你要找什么
			2.你要找多少(*, +, ?, {3, 7})
			3.你要找多少 ^ $

	五.ajax

	str.startWith("123"); 字符串函数 判断字符串以什么开头
	str.endWith("123"); 判断字符串以什么结尾
	trim() 去处字符串两边的空白
	strpos("字符串", 参数) 

	file_get_contents('path'); 读取文件路径
	explode("以什么分割", 分割的内容)  将字符串分割成数组  **必须用双引号表示
	var_dump() 打印变量的相关信息

	C:\\Windows\systems

	netstat -an


	php重点知识:

		超全局变量:
			$GLOBALS --引用全局作用域中可用的全部变量
			$_SERVER --服务器和执行环境信息
			$_GET --用户get方式提交的数据
			$_POST -- 用户post方式提交的数据
			$_FILES -- 文件上传变量, 上传的文件信息(包含文件名.文件类型.大小)
			$_REQUEST -- get, post, cookie数据
			$_SESSION --保存在服务器端的用户隐私数据
			$_ENV --环境变量
			$_COOKIE --保存COOKIE数据(保存在浏览器端的用户隐私数据)

		表单:
			get --- 一般用来拿取数据,浏览器会缓存保留信息
			post--- 一般用来发送数据, 浏览器不会保留信息
			一般登录.注册用post来隐藏个人信息
			$_GET 可以用来接收客户端以get方式传递的参数,格式是 关联数组
			$_POST 可以接受客户端以post方式传递的参数,
			$_REQUEST 可以接收get 或 post 方式提交的数据,但是不用
				a.效率更低下
				b.取值受配置文件的影响

			单按钮 系统会自动的收集当前表单元素的value值
			1.默认情况下,会收集当前被选中的value值, 默认是on
			2.可以为当前按钮设置value值,数据在收集时会将当前的value值提交

			复选框
				1.复选框名称一样,默认传递最后一个选项值
				2.需要传递被选中的复选框的数据,可以在name属性值后面添加[], 添加了[],系统会默认收集所有复选框的值,存储到一个数组中

			下拉列表:
				a.如果,没有设置value值,会默认传递当前被选择option 的innerText值
				b.如果设置了value属性,就会传递value属性

			当表单使用radio时,一定要让相同的name属性设置不同的value值,让服务器可以辨别
			checkbox 如果没有选中,不会提交,选中会提交'on', 可以设置value值来改变提交的数据
			如果需要同时提交多个选中项, 可以在name属性后面跟上[], 最终提交到服务端,通过$_post接收到的是一个索引数组

			1. 在php中,上传文件的请求方式必须是post
			2.上传时必须在表单设置enctype属性
				application/x-www-form-urlencoded: 将参数编码为键值对的格式,
				multipart/form-data: 专门用来处理特殊数据的, 如文件 

			如果一个表单中有文件域(文件上传),必须将表单的 method 设置为 post, enctype 设置为 multipart/form-date

			表单的file类型 里面的属性accept 可以限制文件域能够选择的文件种类,值是MIME Type

			form -> autocomplete="off"; 取消默认提醒
			input -> accept 指定文件类型  multiple 可以让一个文件域多选

		字符串拼接 用点(.)来连接

		单引号:
			不能解析变量
			支持转义
		双引号:
			支持解析变量
			 a:如果在变量名后紧接着着其他的合法字符,那么系统会将整个变量及后面的字符串进行解析
			 	如果需要在这种情况需要正确的解析变量,可以将变量放在{}里
			 b:里面可以识别转义符




		数组:
			count(数组对象) :  获取数组长度
			foreach($arr as $key => $value) {
				echo $key.'--'.$value;
			}

			通过[]创建数组
				1.判断当前数组是否存在, 如果不存在则先创建,再将元素添加到数组第一个元素位置
				2.如果数组存在, 那么就将当前元素添加到数组尾部

			unset() : 可以删除数组中某个成员, 但删除后,不会对数组索引产生影响,元素会保留之前索引, 有动态改变数组的长度
			array_search(数组, 数组元素);  寻找下标
			array_splice(元素, 下标, 删除长度);  截取数组


	函数:
		global: 添加对外部成员的引用

		die(), exit() -- 退出代码执行,当前位置之后的所有代码不执行,可进行程序控制,出错时可执行此语句
		sleep(秒数); -- 执行到sleep函数后 ,延缓一定的秒数


	常量:
		const 常量
		defined () 判断常量是否存在
		define(常量名称,常量值,标记是否对大小写敏感)
		魔术常量:
			_LINE_ : 可以获取当前的代码行
			_FILE_ : 可以获取当前文件的路径 : 目录+文件名
			_DIR_ : 可以获取当前的目录
			_FUNCTION_ : 可以获取当前常量所在的函数

	载入文件: 相当于将被载入文件的代码在当前位置复制一份
		include: 1.如果文件载入失败,也不会影响后面代码执行.
				2,重复载入文件,被载入文件代码会真正的重复执行
		include_once: 如果重复载入文件,最终只会载入一次
		require : 1. 文件载入失败,后面代码不执行
					2.重复载入,可以重复执行
		require_once: 1.文件载入失败,后面不执行
						2.重复载入文件,只执行一次

	字符串:
		strlen(); 获取指定字符串的长度..无法正确的处理中文字符(宽字符集,php默认不支持的字符,会根据当前字符集的编码获取字符占据的字节数)
		mb_internal_encoding(); 获取php环境的默认编码

		explode("分隔符", 目标字符串);  拆分成数组
		implode('连接符', 目标字符串);  合并成数组

		str_replace();  替换
		str_repeat('字符串', 长度);  重复输出
		ucfirst('字符串');  首字母大写
		trim();  去处两边空白;  ltrim(); 去处左边的空白; rtrim(); 去处右边的空白;
		strpos(目标字符串,要查找的子字符串); 查找字符串,从左往右
		strrpos(目标字符串, 要查找的子字符串); 查找字符串,从右往左找
		substr(目标字符串, 起始下标,[截取的长度]);  截取字符串
		strrchr(目标字符串, 截取的起始字符串); 从右开始截取
		strchr(目标字符串, 截取的起始字符串); 从左开始截取
		in_array(目标元素, 目标数组); 判断是否存在数组中

	时间:
		time(); 获取秒数
		date("Y-m-d H:i:s") :格式化本地时间和日期,并返回格式化的日期字符串
		strtotime("1998-7-1"): 将指定日期转为时间戳

		PHP_INT_MAX  php的最大值

	cookie:
		$_COOKIE  超全局变量cookie
		setcookie("名称", "内容", "存在时间", "访问权限的路径 '/'网站根目录 " ".com")
		httponly
			一旦cookie的httponly为真,那么只能在服务端获取.js无法操作
		serialize 序列化数组
		unserialize 得到原来的数组

		session_destroy();  删除session会话文件

		pathinfo() 以数组的形式返回文件路径的信息

		session与cookie之间的区别与联系
		
		l从存储位置：
			cookie存储在浏览器，session存储的服务器端。
		l数据安全性：
			session存储在服务器端，不易获取，更加安全。（cookie存储安全性要求不高的信息）
		l通过HTTP协议传输的数据量：
			每次请求，cookie传输量较大。传递该网站相关的全部的cookie数据。
		l支持的数据类型：
			cookie支持字符串，session几乎所有的数据类型。
			


	file_get_contents : 读取文件内容, 如果成功,会返回一个字符串的值(文件内容), 如果失败,会返回false

	file_put_contents(文件路径, 需要写入的内容.PHP_EOL, FILE_APPEND) 写入文件内容

	move_uploaded_file(文件, 新位置) : 将上传的文件移动到新位置, 成功返回true, 失败返回false 

	uniqid() 动态生成文件名

	exit("字符串");  输出一条消息,并退出当前脚本

	文件上传错误 error:
		UPLOAD_ERR_OK : 值为0, 没有错误发生,文件上传 成功
		UPLOAD_ERR_INI_SIZE: 其值为1, 上传的文件超过了php.ini中的upload_max_filesize选项限制的值
		UPLOAD_ERR_FORM_SIZE: 其值为2, 上传的文件超过了HTML表单中MAX_FILE_SIZE选项限制的值
		UPLOAD_ERR_PARTIAL: 其值为3, 文件只有部分被上传
		UPLOAD_ERR_NOFILE: 其值为4, 没有选择上传文件
		UPLOAD_ARR_NO_TMP_DIR: 其值为6, 找不到临时文件
		UPLOAD_ERR_CANT_WRITE: 其值为7, 写入文件失败
		UPLOAD_ERR_EXTENSION: 其值为8, 上传的文件被php扩展程序中断

	修改php.ini中的 post_max_size配置, 可以让服务器接收更大的请求体体积
	修改php.ini中的 uplode_max_filesize 配置, 让服务端支持更大的单个上传文件

	json:
		1.json文件中,不能写注释.
		2.json文件中, 键必须用双引号.
		3.没有变量名

		json_decode(变量, true); 接受一个 JSON 格式的字符串并且把它转换为 PHP 变量,输出的是一个关联数组
		json_encode(数组); 将一个关联数组转化成json格式

		var arr = JSON.parse(str); 将JSON格式转换成数组
		var str = JSON.stringify(arr); 将数组转换为字符串

	1.如果在php结构中写 return , 那么运行到return代码的时候,整个php文件执行就结束了
	2.如果在方法中使用 return , 那么return 就只能结束这个方法的执行

	implode: 可以将关联的数据以指定的字符串分割,转化为字符串

	chrome://net-internals

	浏览器:
		1.用户在浏览器中输入URL地址
		2.浏览器解析用户输入的URL地址 => 域名 + 端口
		3.浏览器会先检查本地缓存中有没有这个域名 => IP
		4.浏览器发起一个DNS系统调用 => IP
			a.检查操作系统缓存有没有这个域名
			b.找系统的hosts文件中有没有这个域名
			c.如果没有找到.会对DNS服务器发起一个系统调用
		5.浏览器会通过一个本地的随机端口建立一个与服务器指定端口之间的连接通道
		6.浏览器会将客户端的一些信息打上一个"包"
		7.将这个"包"通过这个连接通道发送到服务端
		8.打开服务器返回来的"包",找到Content-Type
		9.根据Content-Type决定如何处理响应的内容
		10.如果是 HTML 则渲染到界面上

	服务器 web Server
		1.打开客户端提交过来的"包",拿到包里面的请求路径
		2.根据请求的路径对应文件的扩展名找到文件的MIME Type
		3.判断文件类型是否为静态文件
		4.如果是静态文件则直接读取这个文件的内容
		5.如果不是静态文件交给"外包公司"
			a.读取文件中的代码
			b.执行代码
			c.将执行结果返回给WebServer
		6.服务端会把要发送给客户端的数据打上一个"包"
		7.将这个包在通过之前的连接通道发回给客户端

	http 约定形式
		1.客户端通过随机端口与服务端某个固定端口(一般为80)建立连接 三次握手
		2.客户端通过这个连接发送请求到服务端(这里的请求是名词)
		3.服务端监听端口得到的客户端发送过来的请求
		4.服务端通过连接响应给客户端状态和内容(响应报文)

	http中的referer用来标识当前请求的来源 PHP_REFERER

	header('Location: 路径'); 客户端浏览器在接收到这个头信息后会自动跳转到指定的地址
		切记不能循环重定向
	header('Content-Type: application/octet-stream'); 让文件下载
	header('Content-Disposition: attachment; filename-demo.tet'); 设置默认下载文件名
	header("refresh:3;url='文件路径'") 三秒钟之后跳转路径

	数据库:
		mysql -hlocalhost -p3306 -uroot -proot

		show datebases; 显示库


		varchar: 长度不固定, 输入多少长度就显示多少长度

		[masqld]  //设置默认字符集,只会影响新建数据库的默认字符集
			character-set-server=utf8;

	查询数据语句得到的是结果集
	增删改语句的得到的是执行这个语句受影响的行数
	SQL 是一套公共标准,不同数据库之间都可以执行,	只不过有一些有特性的点

	查询:
		select `id`,`name`,	`title` from users; 查询具体的类型 
		select * from users; 查询所有 --使用通配符会产生全表扫描,建议指定列名
		select 1 from users;  
		select 语句可以选择列或者一个具体的值
		not 非 and 与 or 或

	新增:
		insert into users (title, name, age, gender) values (`麻子`, 'ceo', 18, 0);
		insert into users  values (`麻子`, 'ceo', 18, 0);

	删除:
		删除数据一定要配合数据筛选
		delete from users where title = 'ufo' and id > 1;
		delete from uses where id in (1,2,3,4);  删除指定的数据

	修改:
		update users set title=`ceo`, name = `zs`; 修改全部
		update users set title=`ceo` where id in (1,2,3,4); 修改指定的语句

	mysqli_connect('主机名','账号','密码','数据库名'); 实现php与数据库服务器的连接
	mysqli_set_charset(连接对象,编码格式字符串 'utf8');  字符编码
	mysqli_query(连接对象, sql语句); 查询
	mysqli_error(连接对象)  可以输出最近一天sql语句执行时产生的错误信息
	mysqli_quert(连接对象, "set names utf-8"); 字符编码
	mysqli_num_rows() 当前结果集中是否有数据
	mysqli_fetch_array(查询语句返回的结果集, 返回内容形式 MYSQL_ASSOC | MYSQL_NUM | MYSQL_BOTH): 提取数据生成一个数组,同时生成索引数组和关联数组
	mysqli_fetch_assoc:生成关联数组
	masqli_fetch_row: 将数据生成索引数组

	富文本编译器
		execCommand()  改变各种属性
		document.contenteditable=true false  //将页面变为富文本
</body>
</html>