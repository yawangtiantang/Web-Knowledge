# 单例模式

## 定义

+ 保证一个类仅有一个实例, 并提供一个访问它的全局访问点

# 策略模式

## 定义

+ 定义一系列的算法, 把它们一个个封装起来,并且使它们可以相互替换

+ 策略模式的程序至少由两部分组成: 第一部分是一组策略类,策略类封装了具体的算法, 并负责具体的计算过程;第二部分是环境类context,context接收客户的请求,随后把请求委托给某个策略类

# 代理模式

## 定义

+ 代理模式是为一个对象提供一个代用品或占位符,以便控制对它的访问

# 迭代器模式

## 定义

+ 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露该对象的内部表示
+ 迭代器模式可以把迭代的过程从业务中分离出来, 在使用迭代器模式之后, 即使不关心对象的内部构造,也可以按顺序访问其中的每个元素

# 发布-订阅模式

## 定义

+ 发布-订阅模式又叫观察者模式,它定义对象间的一种一对多的依赖关系,当一个对象发生改变时, 所有依赖于它的对象都将得到通知.在javascript中,一般用事件模型代替传统的发布-订阅者模式

# 命令模式

+ 命令模式中的命令指的是一个执行某些特定事情的指令

+ 引用场景: 有时需向某些对象发生请求,但并不知道请求的接收者是谁,也不知道被请求的操作是什么. 此时希望用一种松耦合的方式来设计程序, 使得请求发送者和请求接受者能够消除彼此之间的耦合关系

# 组合模式

+ 小的子对象来构建更大的对象, 而这些小的子对象也许由更小的孙对象构成

# 模板方法模式

## 定义

+ 只需使用继承即可实现的简单的模式

+ 由两部分组成: 1.抽象的父类, 2.具体实现的子类. 通常在抽象的父类中封装了子类的算法框架, 包括实现一些公共方法及封装子类中所有方法的执行顺序. 子类通过继承这个抽象类, 也继承了整个算法结构, 并且可以选择重写父类的方法

# 享元模式

+ 享元模式是一种用于性能优化的模式

+ 核心是运用共享技术来支持大量细粒度的对象

# 责任链模式

## 定义

+ 使多个对象都有机会处理请求, 从而避免请求的发送者和接受者之间的耦合关系, 将这些对象连成一条链, 并延着这条链传递该请求, 直到有一个对象处理它为止.

# 中介者模式

## 定义

+ 中介者模式的作用就是解除对象与对象之间的耦合关系. 增加一个中介对象后, 所有的相关对象都通过中介者对象来通信,而不是互相引用, 所以当一个对象发生改变时,只需要通知中介者对象即可. 中介者使各对象之间耦合松散,而且可以独立的改变它们之间的交互. 中介者模式使网状的多对多关系变成了相对简单的一对多关系.

# 装饰者模式

## 定义

+ 装饰着模式可以动态的给某个对象添加一些额外的职责,而不会影响从这个类中派生的其他对象

## 状态模式

## 定义

+ 状态模式的关键是区分事物内部的状态, 事物内部状态的改变往往会带来事物的行为改变
+ 允许一个对象在其内部状态改变时改变它的行为, 对象看起来似乎修改了它的类

## 适配器模式

+ 解决两个软件实体间的接口不兼容的问题

## 外观模式

+ 为一组子系统提供一个简单遍历的访问入口
+ 隔离客户与复杂子系统之间的联系, 客户不用去了解子系统的细节

## 单一职责(SRP)原则

+ 优点: 降低了单个类或者对象的复杂度, 按照职责把对象分解成更小的粒度,有助于代码复用, 也有利于单元测试, 当一个职责需要变更时, 不会影响到其他职责.

+ 缺点: 增加编写代码的复杂度, 当按照职责把对象分解成更小的粒度后, 实际上也增大了这些对象之间相互联系的难度.

## 最少知识原则

+ 软件实体应当尽可能少的与其他实体发生相互作用.
+ 设计程序时, 尽量减少对象之间的交互. 如果两个对象之间不必彼此通信, 那么这两个对象之间就不要发生直接的相互联系. 常用的做法是引入一个第三者对象, 来承担这些对象之间的通信作用,如果一些对象需要向另一些对象发送请求, 可以通过第三者对象来转发这些请求.

## 开放-封闭原则

+ 软件实体(类, 模块, 函数)等应该是可以扩展的, 但是不可修改.
+ 当需要改变一个程序的功能或者给这个程序增加新功能的时候, 可以使用增加代码的方式, 但是不允许改动程序的源代码.

#### 有些代码无法做到完全封闭, 可以做到下面两点

+ 挑选出最容易发生变化的地方, 然后构造抽象来封闭这些变化.
+ 在不可避免发生修改的时候, 尽量修改那些相对容易修改的地方.